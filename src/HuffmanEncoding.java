import java.io.*;
import java.nio.file.Paths;
import java.util.HashMap;
import java.nio.file.Files;
import java.util.Map;
import java.nio.file.Path;
import java.util.PriorityQueue;
import java.util.Scanner;


// Github repo: https://github.com/christophergayiuman/HuffmanEncoding
// Youtube Video: https://www.youtube.com/watch?v=dCm8O1ZxFs8&ab_channel=ChristopherMan

/**
 * This is the main class for the HuffmanEncoding that incorporates everything.
 *
 * The github has more information on how the program operates as well
 * as Acknowledgements/Citations
 */
public class HuffmanEncoding {

    // Make a frequency table:

    static int totalCharLimit = 10000;

    /**
     * @param inputData Takes in the input data (text)
     *                  which is a String
     * @return It returns frequencyArray which is a int array
     * of all the character frequencies up to 10000
     * utf 8 characters
     */
    //Constructs a frequency array from the input data
    public static int[] constructFrequencyTable(String inputData) {

        //Create an array with the total size of ascii characters
        int[] frequencyArray = new int[totalCharLimit];

        //If the character is found within the inputData it will add 1 to its frequency
        for (char character : inputData.toCharArray()) {
            frequencyArray[character]++;
        }
        //Return the frequencyArray
        return frequencyArray;
    }


    // Create node object
    static class Node implements Comparable<Node> {
        private char character;
        private int nodeFrequencyValue;
        Node leftOfNode;
        Node rightOfNode;

        /**
         * @param character Takes a single char called character
         * @param nodeFrequencyValue Takes a single int frequenecy value of the node
         * @param leftOfNode Is the node adjecent to the left of the current node
         * @param rightOfNode Is the node adjectent to the right of the current node
         */
        //each node has its character value, a frequency value, a left and a right node
        private Node(char character, int nodeFrequencyValue, Node leftOfNode, Node rightOfNode) {
            //Assigning the nodes variables
            this.leftOfNode = leftOfNode;
            this.rightOfNode = rightOfNode;
            this.character = character;
            this.nodeFrequencyValue = nodeFrequencyValue;
        }

        /**
         * @return This function leafNodePresent() returns the values of
         * the nodes to the left and the right
         * are null, if they both are it means this node is a leaf
         */
        // If it is a leaf node meaning it has no left or right then assign its left and right to null
        boolean leafNodePresent() {
            return this.rightOfNode == null && this.leftOfNode == null;
        }

        /**
         * compareTo is an Override that allows the subclass to implement a parent class
         * @param nextNode The parameter next node is the next node
         * @return it returns a comparison of this nodes and the nodes adjacent
         */
        @Override
        public int compareTo(Node nextNode) {

            //Comparing the frequency values of the current node and the next node
            int frequencyComparison;

            frequencyComparison = Integer.compare(this.nodeFrequencyValue, nextNode.nodeFrequencyValue);

            // If the node frequency of both values does not equal to zero then return it

            boolean notZero = false;
            if (frequencyComparison != 0) {
                notZero = true;
            }

            if (notZero) {
                return frequencyComparison;
            }

            //Returns the comparison of this nodes character and the next notes character
            return Integer.compare(this.character, nextNode.character);
        }
    }

    // Construct Tree

    /**
     * Parts of this Huffman tree constructions is
     * cited, check the coding commenting below
     * the function constructNodeTree
     *
     * @param frequencyArray takes a int array called freqyencyArray
     *                       that is generated by constrtuctFrequencyTable function
     * @return It returns the huffman node tree in a form of a priority queue
     */
    private static Node constructNodeTree(int[] frequencyArray) {

        //Parts of the construct node tree function and Huffman Decode is referenced from
        /*
         *    Title: HuffmanEncoding
         *    Author: Software Architecture & Design
         *    Date: 22 September 2017
         *    Availability: https://www.youtube.com/watch?v=zSsTG3Flo-I&ab_channel=SoftwareArchitecture%26Design
         *
         *    Title: Huffman Algorithm | Code Tutorial
         *    Author: Quinston Pimenta
         *    Date: 15 June 2014
         *    Availability: https://www.youtube.com/watch?v=ceECSn0W3pE&ab_channel=QuinstonPimenta
         *
         *    Title: Huffman Coding | Greedy Algo-3
         *    Author: geeksforgeeks
         *    Last Updated: 09 Feb, 2021
         *    Availability: https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/
         *
         *    Title: Lecture 17: Huffman Coding
         *    Author: N/A
         *    Last Updated: N/A
         *    Availability: http://home.cse.ust.hk/faculty/golin/COMP271Sp03/Notes/MyL17.pdf
         *
         */

        //Making a priority queue of nodes
        PriorityQueue<Node> nodePriorityQueue = new PriorityQueue<>();

        char i = 0;
        while (i < totalCharLimit) {
            if (frequencyArray[i] > 0) {
                nodePriorityQueue.add(new Node(i, frequencyArray[i], null, null));
            }
            i++;
        }

        int z = 1;

        for (int j = 0; j < nodePriorityQueue.size() + 1000000; j++) {
            if (nodePriorityQueue.size() > z) {
                //Take the first two nodes out of the queue and assign them to left and right nodes
                Node left = nodePriorityQueue.poll();
                Node right = nodePriorityQueue.poll();

                //Then create a largerParentNode that has both left and right nodes
                Node largerParentNode = new Node('\0',
                        left.nodeFrequencyValue + right.nodeFrequencyValue, left, right);

                //Add the largerParentNode back into the queue
                nodePriorityQueue.add(largerParentNode);
            } else {
                break;
            }
        }

        //returns the first node of the queue
        return nodePriorityQueue.poll();
    }


    /**
     * @param node Takes the a node object
     * @param stringValue Takes a string called String Value
     * @param hashMapTable Requires a hashmapTable
     */
    // Create a lookup table
    public static void constructLookupTable(Node node, String stringValue, Map<Character, String> hashMapTable) {

        //If leafNodePresent is false meaning its not a leaf node then add the left and right note with 0 and 1
        if (!node.leafNodePresent()) {
            constructLookupTable(node.leftOfNode, stringValue + '0', hashMapTable);
            constructLookupTable(node.rightOfNode, stringValue + '1', hashMapTable);
        } else {
            //If it is a leaf node then append its character
            hashMapTable.put(node.character, stringValue);
        }
    }


    /**
     * @param data takes in the original String data
     * @param hashMapTable Takes the hashmap of the tree
     * @return it returns the STring after its compressed into 1's 0's
     */
    // Build string
    public static StringBuilder createHuffmanOutput(String data, Map<Character, String> hashMapTable) {
        //Create a new string builder
        StringBuilder buildString = new StringBuilder();

        //For the characters in the String data append its character to the larger string
        for (char character : data.toCharArray()) {
            buildString.append(hashMapTable.get(character));
        }
        return buildString;
    }

    //Create the class and assign it its encoder output and root node
    static class HuffmanEncoderOutput {
        String encoderOutput;
        Node rootNode;

        /**
         * @param encoderOutput Is a String value thats being assigned
         * @param rootNode Is a node object that is the root node being assigned
         */
        public HuffmanEncoderOutput(String encoderOutput, Node rootNode) {
            //Assignign its input to its variables encoder output and rootNode
            this.encoderOutput = encoderOutput;
            this.rootNode = rootNode;
        }

        /**
         * @return Returns the encoder output
         */
        //This function is used to get the encoder output
        public String getEncoderOutput() {
            String EncoderOutput = this.encoderOutput;
            return EncoderOutput;
        }

        /**
         * @return Returns the rootnode
         */
        //This function is used to get the root node of the function
        public Node getRootNode() {
            Node RootNode = this.rootNode;
            return RootNode;
        }

    }

    /**
     * @param data Takes in the original text that is wanted to compress
     * @return it returns a new Object called HuffmanEncoderOutput
     */
    public HuffmanEncoderOutput compressDataInput(String data) {
        //Construct the frequency table using constructFrequencyTable

        int[] frequencyTable = constructFrequencyTable(data);

        //Create the root of the nod tree with the frequency table
        Node root = constructNodeTree(frequencyTable);

        //Create the binary encoding map
        Map<Character, String> hashMapTable = new HashMap<>();
        constructLookupTable(root, "", hashMapTable);
        Map<Character, String> lookupHashMapTable = hashMapTable;

        //Return a huffmanEnocderOutput object with the specifications below
        return new HuffmanEncoderOutput(createHuffmanOutput(data, lookupHashMapTable).toString(), root);
    }

    /**
     * @param output Takes in the new Object
     *               HuffmanEncoderOutput object
     * @return It goes through the huffman tree and
     * assigns characters to a String Builder and
     * returns a String
     */
    //Decode the binary string
    public StringBuilder decodeBinaryString(HuffmanEncoderOutput output) {

        //Set the current Node to the rootNote
        Node currentNode = output.getRootNode();

        //Setting up variables for the loops
        int z = 0;
        final char one = '1';
        final char zero = '0';

        //Create a stringBuilder called outputBuilder
        StringBuilder outputBuilder = new StringBuilder();


        while (z < output.getEncoderOutput().length()) {

            //If the current node is not a leaf node
            while (!currentNode.leafNodePresent()) {

                //If the bit is 1 then assign it to the right node, if its 0 then assign to the left node.
                char currentOneOrZero = output.getEncoderOutput().charAt(z);

                switch (currentOneOrZero) {
                    case zero:
                        currentNode = currentNode.leftOfNode;
                        break;
                    case one:
                        currentNode = currentNode.rightOfNode;
                        break;
                }

                //Increase z, moves on to the next one or zero char within the string
                z++;
            }

            outputBuilder.append(currentNode.character);
            currentNode = output.getRootNode();

        }

        return outputBuilder;
    }


    /**
     * @param nameOfFile Takes in a String that will decide
     *                   what the path of the textfile
     *                   you want to convert to a string
     * @return It returns the contents of the textfile that
     * is converted into the string
     * @throws IOException incase there is an error with reading the text file
     */
    //Read the textfile to string:
    public static String textFileToString(String nameOfFile) throws IOException {
        //Remove all of the line breaks
        Path filename = Path.of(nameOfFile);
        String content = Files.readString(filename);
        content = content.replace("\n", "").replace("\r", " ");
        return content;
    }

    /**
     * This code is used from the week 9 workshop that is given from Professor Chico
     * @param s String s
     * @return data
     */
    //CHICO'S CODE WEEK 9
    static byte[] GetBinary(String s) {
        StringBuilder sBuilder = new StringBuilder(s);
        while (sBuilder.length() % 8 != 0) {
            sBuilder.append('0');
        }
        s = sBuilder.toString();

        byte[] data = new byte[s.length() / 8];

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '1') {
                data[i >> 3] |= 0x80 >> (i & 0x7);
            }
        }
        return data;
    }


    /**
     * Just prints out the words of how long it took for execution of the program
     */
    public static void display(){
        System.out.println("Time it took for execution: ");
    }

    /**
     * Just prints out the main menu options
     */
    public static void mainMenu(){
        System.out.println(" ");
        System.out.println("         Welcome to the huffman compression application");
        System.out.println(" ");
        System.out.println("(Note): Make sure the file you want to compress is pasted within the project folder");
        System.out.println(" --To quit please type 0--");
        System.out.println(" ");
        System.out.println("What is the name of the file you want to compress: (note:) CASE SENSITIVE");
    }

    /**
     * Just prints out he decod menu after compression
     */
    public static void decodeMenu(){
        System.out.println("Your text has now been compressed to the output_file.bin within" +
                " the same directory as your text");

        System.out.println(" ");
        System.out.println("Would you like to decode the text?");
        System.out.println(" --1. Yes--");
        System.out.println(" --0. No--");

    }

    public static void main(String[] args) throws IOException {

        boolean lobbyLoop = true;

        while (lobbyLoop) {


            mainMenu();

            //Main function of the program
            try {
                //Create scanner object
                Scanner lobbyScanner = new Scanner(System.in);

                //Reads the user input answer for the main menu
                String textName;
                String userFile = lobbyScanner.nextLine();
                System.out.println(" ");

                //tests if the user chose to quit
                switch (userFile){
                    case "0":
                        System.exit(1);
                        break;
                    default:
                        break;
                }
                long start = System.currentTimeMillis();

                //Create a new huffman object
                textName = userFile;
                HuffmanEncoding encoder = new HuffmanEncoding();

                //Read the text file and append to a string
                String content = textFileToString(textName);

                //Using huffman encoding to compress the data
                HuffmanEncoderOutput result = encoder.compressDataInput(content);
                String compressedContent = result.encoderOutput;

                //Write the compressed 0101 to a file called compressed.txt
                PrintWriter output = new PrintWriter("compressed.txt");
                output.println(compressedContent);
                output.close();

                //Read from compressed.txt into a string called compressedData
                String compressedData = textFileToString("compressed.txt");


//          CHICOS CODE FROM WEEK 9:
                String binary_string_a = compressedData;
                byte[] converted = GetBinary(binary_string_a);

                // Save bit array to file
                try {
                    OutputStream outputStream = new FileOutputStream("output_file.bin");
                    outputStream.write(converted);

                } catch (IOException e) {
                    e.printStackTrace();
                }

                // Load bit array from file
                try {
                    byte[] allBytes = Files.readAllBytes(Paths.get("output_file.bin"));

                    for (int i = 0; i < 3; i++) {
                        char c = (char) allBytes[i];

                    }

                } catch (IOException ex) {
                    ex.printStackTrace();
                }

                long end = System.currentTimeMillis();
                long executionTime = end - start;
                System.out.println("Time to execute: " + executionTime + " milliseconds");
//          END OF CHICOS'S WEEK 9 CODE

                //Prints out the decode menu
                decodeMenu();


                //Checks if the user wants to have their decoded answer be printed into the terminal window
                String decodeTextAnswer = lobbyScanner.nextLine();
                switch (decodeTextAnswer){
                    case "1":
                        System.out.println(" ");
                        System.out.println(encoder.decodeBinaryString(result));
                        System.out.println(" ");
                        break;
                    default:
                        break;
                }



//                Catches all errors, prints that there is an error and the main program loop continues
            } catch (Exception e) {
                System.out.println(" ");
                System.out.println("-----");
                System.out.println("there is an error, please reinput the file's name carefully");
                System.out.println("The error is: " + e);
                System.out.println("-----");

            }

            //Calcaultes the time it took to execute the program



        }

    }
}
